using MultiPlayer.Server.Communications;
using MultiPlayer.Server.Communications.Base;
using MultiPlayer.Server.DTO;
using MultiPlayer.Server.Enums;
using System.Net;
using System.Net.Sockets;
using System.Text;
using static MultiPlayer.Server.Communications.Base.AConnectionProtSocket;

namespace MultiPlayer.Server.Module.Base
{
    public enum State
    {
        Unstarted = 0,
        Starting,
        Active,
        ShuttingDown,
        Crashed
    }

    public abstract class AModule
    {
        public string Name { get; set; }
        public int ActiveConnectionCount => _connections.Count;
        public abstract int MaxConnections { get; }//could be instance varied. Like different size maps, modes, etc.
        public State State { get; protected set; }
        public string StateTxt { get; protected set; }


        protected byte Sync { get; private set; } = 0;
        protected AConnectionProtSocket _socket;
        protected List<ActiveConnection> _connections;

        private LogHandle _logger;
        private int _lastID = 0;

        protected AModule(LogHandle logger)
        {
            _connections = new List<ActiveConnection>();
            _logger = logger;
        }

        //lifetime events
        public virtual void Start(IPAddress ipAddress, int port, ConnType connectionType)
        {
            _socket = CreateInstance(ipAddress, port, connectionType);
            _socket.Start();

            State = State.Active;
        }

        public virtual void Stop()
        {
            foreach (var conn in _connections)
                conn.Stop();

            _connections.Clear();

            _socket.Close("Server close requested");
            _socket = null;

            State = State.Unstarted;
        }

        public void SetChrashed()
        {
            State = State.Crashed;
        }

        public abstract void JoinConnection();

        public void CheckForIncomingData(ActiveConnection conn)
        {
            //this probably locks up
            //async read until full stop, then provide full-whole "packet" to process?
            //Alternative 2: read as many bytes as possible; assemble until a "known end" is reached; pass further to process and react.
            if (conn.DataAvailable)
            {
                var packet = conn.ReceivePacket();

                switch (packet.Type)
                {
                    //case PacketType.ConnectJoin:; //i'm not sure we use it actually.
                    case PacketType.Reconnect: ProcessReconnect(conn.ConnID, packet.PacketData); break;
                    case PacketType.Disconnect: ProcessPlayerQuit(conn); break;
                    case PacketType.NormalComms: ProcessIncomingPacket(conn.ConnID, packet.PacketData); break;
                    default:
                        throw new Exception($"Invalid packet {packet.Type}");
                }

                conn.LastContact = DateTime.UtcNow;
            }

            HandleInactivity(conn);
        }

        public void Update(double dTime)
        {
            Sync++;
            UpdateInternal(dTime);
        }


        protected abstract void ProcessIncomingPacket(int connID, byte[] data);
        protected abstract void ProcessReconnect(int connID, byte[] data);
        protected abstract void HandleInactivity(ActiveConnection conn);


        protected abstract void UpdateInternal(double dTime);
        public abstract void BroadcastState();

        //common childdren functions
        protected int GetNextID()
        {
            return ++_lastID;
        }

        protected void Log(string message)
        {
            _logger.Log(message);
        }

        protected void SendGreetingMsg(ActiveConnection conn)
        {
            var msg = $"{{\"YourID\":{conn.ConnID}, \"MSG\":\"Welcome!\"}}";
            var packet = ServerPacket.Construct(PacketType.ConnectJoin, Sync, msg);
            conn.SendPacket(packet);
        }

        protected void SendFarewellMsg(ActiveConnection conn)
        {
            var msg = $"{{\"MSG\":\"Bye bye!!\"}}";
            var packet = ServerPacket.Construct(PacketType.Disconnect, Sync, msg);
            conn.SendPacket(packet);
        }

        protected void ProcessPlayerQuit(ActiveConnection conn)
        {
            SendFarewellMsg(conn);
            conn.Stop();
            RemoveConnection(conn);
        }

        protected void AddConnection(ActiveConnection connection)
        {
            _connections.Add(connection);
        }

        protected void RemoveConnection(ActiveConnection connection)
        {
            _connections.Remove(connection);
        }

        internal void PreProcessConnection()
        {
            var connProviders = _connections.Select(x => x.GetConnectionProvider());
            _socket.ProcessProtocolQuirks(connProviders);

            if (_socket.IsConnectionPending)
                ProcessConnecting();
        }

        private void ProcessConnecting()
        {
            JoinConnection();
        }

        internal void ProcessActiveConnections()
        {
            for (int i = _connections.Count - 1; i >= 0; i--)
            {
                var conn = _connections[i];
                CheckForIncomingData(conn);
            }
        }
    }
}
