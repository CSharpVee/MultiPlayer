using System.Net;
using System.Net.Sockets;

namespace MultiPlayer.Server.Communications
{
    public abstract class AClientConnection
    {
        public abstract IPEndPoint Endpoint { get; }
        public abstract bool IsDataAvailable { get; }
        public abstract void Close(string reason);

        //maybe this ↓↓↓ ? so we don't expose streamless protocol behavior as with UDP
        public abstract void SendBytes(byte[] data);
        public abstract byte[] ReceiveBytes(ushort amount);
    }

    public class TCP_ClientConnection : AClientConnection
    {
        public override IPEndPoint Endpoint => _endpoint;
        public override bool IsDataAvailable => _stream.DataAvailable;

        private TcpClient _client;
        private NetworkStream _stream;
        private IPEndPoint _endpoint;

        public TCP_ClientConnection(TcpClient inClient)
        {
            _client = inClient;
            _stream = _client.GetStream();
            _endpoint = _client.Client.RemoteEndPoint as IPEndPoint;
        }

        public override void Close(string reason)
        {
            _stream.Dispose();
            _client.Dispose();
        }

        public override byte[] ReceiveBytes(ushort amount)
        {
            var bytes = new byte[amount];
            _stream.Read(bytes);
            return bytes;
        }

        public override void SendBytes(byte[] data)
        {
            _stream.Write(data);
        }
    }

    public class UDP_ClientConnection : AClientConnection
    {
        public override IPEndPoint Endpoint => _endptIP;

        public override bool IsDataAvailable => _dataPacketQueue.Count > 0;//and this could be other

        private UdpClient _mainServerInst;
        private IPEndPoint _endptIP;

        private List<byte[]> _dataPacketQueue;
        private int _bytePointer = 0;

        public UDP_ClientConnection(UdpClient serverInst, IPEndPoint endpoint)
        {
            _dataPacketQueue = new List<byte[]>();
            _endptIP = endpoint;
            _mainServerInst = serverInst;//don't ever close this anywhere inside!!
        }

        public void PushNewData(byte[] data)
        {
            _dataPacketQueue.Insert(0, data);
        }

        public override void Close(string reason)
        {
            //don't ever close. Uses same UDP client instance
        }

        public override byte[] ReceiveBytes(ushort amount)
        {
            var result = new byte[amount];
            var lastIndex = _dataPacketQueue.Count - 1;//because we insert new data to the list[0]
            var data = _dataPacketQueue[lastIndex];
            
            var packetFinished = _bytePointer + amount >= data.Length;
            var copyAmt = (!packetFinished) ? amount : data.Length - _bytePointer;

            Buffer.BlockCopy(data, _bytePointer, result, 0, copyAmt);

            if (packetFinished)
            {
                _bytePointer = 0;
                _dataPacketQueue.RemoveAt(lastIndex);
            }
            else _bytePointer += copyAmt;
            return result;
        }

        public override void SendBytes(byte[] data)
        {
            _mainServerInst.Send(data, data.Length, _endptIP);
        }
    }
}
