using MPClientBase.DTO;
using MPModuleBase.Communications;
using MPModuleBase.Module;
using MPModuleBase.Module.Base;
using MPModuleBase.Utilities;
using System.Text;

namespace MultiPlayer.TestClasses
{
    internal class TestHotswapChat : AModuleBlueprint
    {
        public override string Name => "MirC HS server";
        public override string GetVersion => "-1.1";
        public override string GetExpectedServerVersion => "0.45.5";
        public override int TargetFPS => 5;

        public override AModule CreateInstance(LogHandle logger)
        {
            return new TestHotswapModule(logger);
        }
    }

    internal class TestHotswapModule : AHotswappableModule
    {
        private List<string> _savedLines = new List<string>();
        private bool _sendLast = false;
        private double _elapse;

        //this essentially leaks when connections drop. I know. It's just a test module. Relax! IT'S YOU WHO ARE SHOUTING!!!!
        private Dictionary<int, string> _connNames = new Dictionary<int, string>();

        public override int MaxConnections => 50;

        public TestHotswapModule(LogHandle logger) : base(logger)
        {

        }

        public override void BroadcastState()
        {
            if (!_sendLast)
                return;

            var packet = ServerPacket.Construct(PacketType.NormalComms, Sync, _savedLines.Last());

            foreach (var connection in _connections)
                connection.SendPacket(packet);

            _sendLast = false;
        }

        public override void Start(AConnectionProtSocket inSocket)
        {
            base.Start(inSocket);
            _elapse = 0;
            State = State.Starting;
        }

        protected override void UpdateInternal(double dTime)
        {
            _elapse += dTime;

            if (_elapse > 1.3f)
                State = State.Active;

            StateTxt = $"{_elapse:0.##}";
        }

        protected override void ProcessIncomingPacket(int connID, byte[] data)
        {
            var purpose = (Purpose)data[0];
            switch (purpose)
            {
                case Purpose.Hearbeat: break;//just ignore, AModule handles what's needed
                case Purpose.ChangeName:
                    SetName(connID, Encoding.ASCII.GetString(data, 1, data.Length - 1));
                    break;
                case Purpose.SendMessage:
                    SaveNewMessage(connID, Encoding.ASCII.GetString(data, 1, data.Length - 1));
                    break;
            }
        }

        private void SetName(int connID, string newName)
        {
            _connNames[connID] = newName;
        }

        private void SaveNewMessage(int connID, string msg)
        {
            var name = _connNames.ContainsKey(connID) ? _connNames[connID] : "???";
            var dataStr = $"{name} : {msg}";
            _savedLines.Add(dataStr);
            _sendLast = true;
        }

        public enum Purpose
        {
            Hearbeat = 0,
            ChangeName = 1,
            SendMessage = 2
        }
    }
}
