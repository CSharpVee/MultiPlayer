using MultiPlayer.Server.Communications;
using MultiPlayer.Server.DTO;
using System.Net.Sockets;
using System.Text;

namespace MultiPlayer.Server.Module
{
    public enum State
    {
        Unstarted = 0,
        Starting,
        Active,
        ShuttingDown,
    }

    public abstract class AModule
    {
        protected IConnectionContainer _parentContainer;
        protected byte Sync { get; private set; } = 0;
        private int _lastID = 0;

        public abstract string Name { get; }//DLL server's name. Aka, what's running?
        public abstract string GetVersion { get; } //Dll version
        public abstract string GetExpectedServerVersion { get; } //Version that this DLL expects of the server
        public abstract int MaxConnections { get; }
        public abstract int TargetFPS { get; }


        public State State { get; protected set; } //Instance state
        public string StateTxt { get; protected set; } //Instance state



        //lifetime events
        public virtual void Start() { State = State.Active; }
        public virtual void Stop() { State = State.Unstarted; }

        public abstract void JoinPlayer(AConnectionProtocol socket);

        public void CheckForIncomingData(ActiveConnection conn)
        {
            //this probably locks up
            //async read until full stop, then provide full-whole "packet" to process?
            //Alternative 2: read as many bytes as possible; assemble until a "known end" is reached; pass further to process and react.
            if (conn.DataAvailable)
            {
                var packet = conn.ReceivePacket();

                switch(packet.Type)
                {
                    //case PacketType.ConnectJoin:; //i'm not sure we use it actually.
                    case PacketType.Reconnect: ProcessReconnect(conn.ConnID, packet.PacketData); break;
                    case PacketType.Disconnect: ProcessPlayerQuit(conn); break;
                    case PacketType.NormalComms: ProcessIncomingPacket(conn.ConnID, packet.PacketData); break;
                    default:
                        throw new Exception($"Invalid packet {packet.Type}");
                }

                conn.LastContact = DateTime.UtcNow;
            }

            HandleInactivity(conn);
        }

        public void Update(double dTime)
        {
            Sync++;
            UpdateInternal(dTime);
        }


        protected abstract void ProcessIncomingPacket(int connID, byte[] data);
        protected abstract void ProcessReconnect(int connID, byte[] data);
        protected abstract void HandleInactivity(ActiveConnection conn);


        protected abstract void UpdateInternal(double dTime);
        public abstract void BroadcastState(IEnumerable<ActiveConnection> connections);

        internal void SetParentContainer(IConnectionContainer parentContainer)
        {
            _parentContainer = parentContainer;
        }

        //common childdren functions
        protected int GetNextID()
        {
            return ++_lastID;
        }

        protected void SendGreetingMsg(ActiveConnection conn)
        {
            var msg = $"{{\"YourID\":{conn.ConnID}, \"MSG\":\"Welcome!\"}}";
            var packet = ServerPacket.Construct(PacketType.ConnectJoin, Sync, msg);
            conn.SendPacket(packet);
        }

        protected void SendFarewellMsg(ActiveConnection conn)
        {
            var msg = $"{{\"MSG\":\"Bye bye!!\"}}";
            var packet = ServerPacket.Construct(PacketType.Disconnect, Sync, msg);
            conn.SendPacket(packet);
        }

        protected void ProcessPlayerQuit(ActiveConnection conn)
        {
            SendFarewellMsg(conn);
            conn.Stop();
            _parentContainer.RemoveConn(conn);
        }
    }

    public abstract class AHotswappableModule : AModule
    {
        public sealed override void JoinPlayer(AConnectionProtocol socket)//do we seal it or make it overrideable by children. Probably make it overrrideable for custom authentication'n'shit.
        {
            if (_parentContainer.ActiveConnCount < MaxConnections)
            {
                var client = socket.AcceptClientConnection();
                var id = GetNextID();
                var conn = new ActiveConnection(client, id);

                _parentContainer.AddConn(conn);
                SendGreetingMsg(conn);
            }
            else
            {
                socket.Close("Go away now!");
            }
        }

        protected override void HandleInactivity(ActiveConnection conn)
        {
            if ((DateTime.UtcNow - conn.LastContact).TotalSeconds > 10)
            {
                conn.Inactive = true;
            }
        }

        protected sealed override void ProcessReconnect(int connID, byte[] data)
        {
            throw new InvalidOperationException("Reconnection attempted in a non-reconnecting module");
        }
    }

    public abstract class AReconnectingModule : AModule
    {
        protected sealed override void ProcessReconnect(int connID, byte[] data)
        {
            throw new NotImplementedException("Not yet implemented");

        }
    }
}
